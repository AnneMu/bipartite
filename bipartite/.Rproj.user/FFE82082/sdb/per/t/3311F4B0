{
    "contents" : "`networklevel` <- function(web, index=\"ALLBUTDD\", level=\"both\", weighted=TRUE, ISAmethod=\"Bluethgen\", SAmethod=\"Bluethgen\", extinctmethod=\"r\", nrep=100, CCfun=median, dist=\"horn\", normalise=TRUE, empty.web=TRUE, logbase=\"e\", intereven=\"prod\", H2_integer=TRUE, fcweighted=TRUE, fcdist=\"euclidean\", legacy=FALSE){\n    ##\n    ## web         interaction matrix, with lower trophic level in rows, higher in columns\n    ## legacy      se to TRUE allows to run networklevel in its old form\n#! JFedit: fddist and fdweighted replace throughout by fcdist and fcweighted\n  \n    if(empty.web) {web <- empty(web)}\n    web.e <- empty(web) # emptied web for some indices \n    if (NROW(web) < 2 | NCOL(web) <2) warning(\"Web is really too small to calculate any reasonable index. You will get the values nonetheless, but I wouldn't put any faith in them!\")\n    \n    allindex <- c( #descriptive:\n        \"number of species\", \"connectance\", \"web asymmetry\", \n        #binary based and related:\n        \"links per species\", \"number of compartments\", \"compartment diversity\",\n        \"cluster coefficient\", \"degree distribution\", \"mean number of shared partners\",\n        \"togetherness\", \"C score\", \"V ratio\", \"discrepancy\", \"nestedness\", \n        \"weighted nestedness\",\n        #miscelleneous:\n        \"ISA\", \"SA\", \"extinction slope\", \"robustness\", \"niche overlap\",   \n        #quantitative series:\n        \"weighted cluster coefficient\", \"weighted NODF\", \"partner diversity\", \"generality\", \"vulnerability\", \"linkage density\", \"weighted connectance\", \"Fisher alpha\",  \"interaction evenness\", \"Alatalo interaction evenness\", \"Shannon diversity\", \"functional diversity\", \"H2\" )\n    # GONE: \"mean interaction diversity\", \"effective partners\", \n    \n    index <- unique(index) # enforces that each index name is used only once\n    \n    wrong.name <- which(is.na(pmatch(index, c(allindex, \"ALL\", \"ALLBUTDD\", \"info\",\"quantitative\", \"binary\", \"topology\", \"networklevel\"))))\n    if (length(wrong.name) > 0) stop(\"You selected an index that is not available: \", paste(index[wrong.name], collapse=\", \"))\n    \n    # only if indices are not given explicitly:\n    if (length(index)==1 & !all(index %in% allindex)){\n        index <- switch(index,\n                        \"ALL\" = allindex,\n                        \"ALLBUTDD\" = allindex[-which(allindex==\"degree distribution\")],\n                        \"info\" = c(\"number of species\", \"connectance\", \"web asymmetry\", \"links per species\", \"number of compartments\"),\n                        # logic: only rough information on the network's general structure\n                        \"quantitative\" = c(\"weighted cluster coefficient\", \"weighted nestedness\", \"weighted NODF\", \"functional diversity\", \"partner diversity\", \"effective partners\", \"H2\", \"diversity\",\"linkage density\", \"weighted connectance\", \"niche overlap\"), #\"mean interaction diversity\", \n                        # logic: the \"quantitative series\"\n                        \"binary\" = c(\"connectance\", \"links per species\", \"nestedness\", \"mean number of partners\",\"cluster coefficient\",  \"C-score\", \"Fisher alpha\"),\n                        # logic: metrics for binary networks\n                        \"topology\" = c(\"connectance\", \"cluster coefficient\", \"degree distribution\", \"togetherness\", \"nestedness\"),\n                        # logic: more abstract, topological metrics for binary networks\n                        \"networklevel\" = c(\"connectance\", \"web asymmetry\", \"links per species\", \"number of compartments\", \"compartment diversity\", \"cluster coefficient\", \"nestedness\", \"weighted NODF\", \"ISA\", \"SA\", \"linkage density\", \"Fisher alpha\", \"diversity\", \"interaction evenness\", \"Alatalo interaction evenness\", \"H2\"),\n                        # only the truly networky indices\n                        stop(\"Your index is not recognised! Typo? Check help for options!\", call.=FALSE) #default for all non-matches\n        )\n    }\n    \n    if (legacy == FALSE){\n        \n        out <- list()\n        # first: all the true networklevel indices\n        #--------------------\n        if (\"connectance\" %in% index){\n            # connectance: \"the fraction of all possible links that are realized in a network\", (p. 12917 in Dunne et al. 2002)\n            suppressWarnings(out$connectance <- sum(web>0)/prod(dim(web)))\n        }\n        #--------------------\n        if (\"web asymmetry\" %in% index) out$\"web asymmetry\" <- (NCOL(web)-NROW(web))/sum(dim(web))     # web asymmetry (Blüthgen et al. 2007, Fig. S2)\n        #--------------------\n        if (\"links per species\" %in% index){\n            L <- sum(web>0)/sum(dim(web))\n            out$\"links per species\"=L\n        }\n        #--------------------\n        if (any(c(\"number of compartments\", \"compartment diversity\") %in% index)){\n            CD <- function(co){\n                if (co$n.compart>1){\n                    no <- NA\n                    for (i in 1:co$n.compart){\n                        comp <- which(abs(co$cweb)==i, arr.ind=TRUE) # who is in a compartment?\n                        no[i] <- length(unique(comp[,1])) + length(unique(comp[,2])) # how many species\n                    }\n                    no <- no/sum(dim(web)) # standardise for number of species in the web\n                    CD <- exp(-sum(no*log(no)))\n                }  else {CD <- NA} #; warning(\"only one compartment\")}\n                CD\n            }\n            \n            comps <- try(compart(web.e), silent=TRUE)\n            if (class(comps)==\"try-error\") {\n                ncompart <- compdiv <- NA\n            } else  {\n                ncompart <- comps$n.compart\n                compdiv <- CD(comps)\n            }\n            if (\"number of compartments\" %in% index) out$\"number of compartments\" <- as.integer(ncompart)\n            if (\"compartment diversity\" %in% index) out$\"compartment diversity\" <- compdiv\n        }\n        #------------------------\n        if (\"cluster coefficient\" %in% index){\n            cluster.coef <- function(web, full=FALSE, FUN=mean){\n                # calculate cluster coefficient\n                # web   a bipartite web\n                # full  logical; return cluster coefficients for each species in the network?\n                # FUN   give a function to summarise individual cluster coefficients, defaults to 'mean'.\n                # The concept was introduced by Watts & Strogatz (1998) and is described under in Wikipedia under http://en.wikipedia.org/w/index.php?title=Clustering_coefficient\n                # Its main idea was to help identifying small-world networks, which should\n                # have high cluster coefficients but low path lengths.\n                # Ci of species i is simply the number of realised links devided by the number of possible links. At the network level, the CC for a network is the average CC of its members. This is a little bit fishy, since the CCs are log-normal\n                # distributed (in pollinations networks at least). Therefore with FUN also\n                # other summary measures can be employed.\n                # Because within 'bipartite' we look at 2-mode networks, mean C is:\n                # C_lowertrophiclevel = C_highertrophiclevel = C_entirenetwork.\n                #\n                # Literature: Watts DJ, Strogatz S (1998) Collective dynmics of 'small-world' networks. Nature 393:440-442\n                \n                # notice that this CC differs from the binary version of Tore Opsahl's. This here is the same as the one-mode cluster coefficient, Tore's is the \"corrected\" two-mode!\n                web <- as.matrix(web)\n                Ci.high <- colSums((web>0))/nrow(web)\n                Ci.low <- rowSums((web>0))/ncol(web)\n                CC <- FUN(Ci.high)\n                if (full) out <- list(\"cluster coefficient\"=CC, \"CC values higher\"=Ci.high,\n                                      \"CC values lower\"=Ci.low) else out <- c(\"cluster coefficient\"=CC)\n                out\n            }\n            out$\"cluster coefficient\"=as.numeric(cluster.coef(web, FUN=CCfun, full=FALSE))\n        }\n        #-------------------\n        if (\"nestedness\" %in% index){\n            nest <- try(nestedtemp(web)$statistic, silent=TRUE)\n            out$nestedness <- ifelse(class(nest)==\"try-error\", NA, nest)\n            # a fast implementation of nestedness by Jari Oksanen\n            #old: nestedness(web, null.models=FALSE)$temperature\n        }\n        #-------------------\n        if (\"weighted nestedness\" %in% index){\n            wine.res <- try(wine(web.e, nreps=nrep)$wine, silent=TRUE)\n            out$\"weighted nestedness\" <- if (!inherits(wine.res, \"try-error\")) {wine.res} else {NA}\n        }\n        #-------------------\n        if (\"weighted NODF\" %in% index){\n\t\t\tNODF <- try(unname(nestednodf(web, order=TRUE, weighted=TRUE)$statistic[3]), silent=TRUE)\n            out$\"weighted NODF\" <- if (inherits(NODF, \"try-error\")) NA else NODF\n        }\n        #------------------\n        if (any(c(\"ISA\", \"interaction strength asymmetry\", \"dependence asymmetry\") %in% index)){\n            # Dependence asymmetry (Bascompte et al. 2006; Blüthgen et al. 2007, Fig. S2)\n            depL <- web.e/matrix(rowSums(web.e), nrow=NROW(web.e), ncol=NCOL(web.e), byrow=FALSE)\n            depH <- web.e/matrix(colSums(web.e), nrow=NROW(web.e), ncol=NCOL(web.e), byrow=TRUE)\n            \n            if (ISAmethod==\"Bascompte\" & \"ISA\" %in% index) {\n                #depMax <- depL\n                #greaterindex <- depL < depH\n                #depMax[greaterindex] <- depH[greaterindex]\n                \n                out$\"dependence asymmetry\"=mean(abs(depL-depH)/pmax(depL, depH), na.rm=TRUE)\n            }\n            if (ISAmethod==\"Bluethgen\" & \"ISA\" %in% index) {\n                web2 <- web\n                # delete cells for species encountered only once (Blüthgen, pers. comm.):\n                web2[, which(colSums(web)==1)] <- 0\n                web2[which(rowSums(web)==1), ] <- 0\n                rowsummat <- matrix(rowSums(web2), nrow=NROW(web2), ncol=NCOL(web2), byrow=FALSE)\n                colsummat <- matrix(colSums(web2), nrow=NROW(web2), ncol=NCOL(web2), byrow=TRUE)\n                depL <- web2/rowsummat\n                depH <- web2/colsummat\n                \n                depL[depL<=0] <- NA\n                depH[depH<=0] <- NA\n                # now we need a correction to account for the fact that links with few (e.g. 2) observations will have a minimum depL of 1/2: all on one species: depL=1, one on each of two: depL=0.5\n                depLprime <- (depL - 1/rowsummat)/(1 - 1/rowsummat) \n                # assumes depLmin = 1/web2 and depLmax=1\n                depHprime <- (depH - 1/colsummat)/(1 - 1/colsummat)\n                \n                out$\"interaction strength asymmetry\"=mean(as.matrix(depHprime-depLprime), na.rm=TRUE) #ranges from -1 to 1 /sum(depLprime, depHprime, na.rm=TRUE)\n            }\n        }\n        #------------------\n        if (\"SA\" %in% index){\n            # Specialisation asymmetry (Blüthgen et al. 2007, Fig. S2)\n            # 2 options for calculating the \"mean\" SA:\n            # either as Blüthgen et al: average weighted by number of interactions in the \n            # cell or as mean of logarithms (since the dependencies follow a lognormal\n            # distribution)\n            di <- dfun(web)$dprime  # plants\n            dj <- dfun(t(web))$dprime # pollinators\n            if (SAmethod==\"log\"){\n                lgmeani <- mean(log(di[di>0])); lgmeanj <- mean(log(dj[dj>0]))\n                SA <- (lgmeanj-lgmeani)/sum(lgmeani, lgmeanj)  \n                # ij-sequence changed because log changes sequence, too\n            }\n            if (SAmethod==\"Bluethgen\"){\n                wmeani <- sum(di*rowSums(web.e))/sum(web.e)\n                wmeanj <- sum(dj*colSums(web.e))/sum(web.e)\n                SA <- (wmeanj-wmeani)/sum(wmeani, wmeanj) \n                # positive values indicate more specialisation in the higher trophic level\n            }\n            out$\"specialisation asymmetry\" <- SA \n        }\n        #------------------\n        if (\"linkage density\" %in% index){\n            # for formula see Tylianakis et al. (2006), supplement.\n            # N refers to prey, P to predators\n            \n            preytot.mat <- matrix(rep(colSums(web), NROW(web)), NROW(web), byrow=TRUE)\n            preyprop.mat <- web/preytot.mat  # = b_ik/b_.k in the first formula\n            #H_Nk is the diversity index of inflow (diversity of flower visits for each pollinator)\n            predtot.mat <- matrix(rep(rowSums(web), NCOL(web)), NROW(web), byrow=FALSE)\n            predprop.mat <- web/predtot.mat  # = b_kj/b_.k in the second formula\n            \n            if (logbase==2 | logbase==\"2\"){\n                H_Nk <- apply(preyprop.mat, 2, function(x) -sum(x*log2(x), na.rm=TRUE))\n                #H_Pk is the diversity index of pollinators for each plant species\n                H_Pk <- apply(predprop.mat, 1, function(x) -sum(x*log2(x), na.rm=TRUE))\n                # next, we need the reciprocals of this\n                # note that the ifelse is only needed if the web contains prey that is\n                # not eaten or predators that don't eat ...\n                n_Nk <- ifelse(colSums(web)!=0, 2^H_Nk, 0)\n                n_Pk <- ifelse(rowSums(web)!=0, 2^H_Pk, 0)\n            }\n            if (logbase==\"e\"){ # same code as above, just with \"e\"\n                H_Nk <- apply(preyprop.mat, 2, function(x) -sum(x*log(x), na.rm=TRUE))\n                H_Pk <- apply(predprop.mat, 1, function(x) -sum(x*log(x), na.rm=TRUE))\n                n_Nk <- ifelse(colSums(web)!= 0, exp(H_Nk), 0)\n                n_Pk <- ifelse(rowSums(web)!= 0, exp(H_Pk), 0)\n            }\n            # mean number of predators per prey\n            V <- sum(rowSums(web)/sum(web)*n_Pk)\n            # marginal totals-weighted mean exp(Shannon diversity)\n            G <- sum(colSums(web)/sum(web)*n_Nk)\n            # linkage density\n            LD_q <- 0.5*(V+G)\n            #------------------\n            out$\"linkage density\"=LD_q\n            if (\"weighted connectance\" %in% index) out$\"weighted connectance\" <- LD_q/sum(dim(web))\n            #LD_qs <- LD_q/(NROW(web)+NCOL(web)) # \"weighted food web connectance\", according to Jason's appendix\n            #------------------\n            # #We found no reference to this metric and saw little use for it. It is very similar to vulnerability/generality and can easily be computed from the output of \\code{\\link{specieslevel}} as \\code{mean(specieslevel(web, index=\"diversity\"))}        \n            # if (\"mean interaction diversity\" %in% index){\n            # out$\"interaction diversity LTL\" <- mean(H_Nk)\n            # out$\"interaction diversity HTL\" <- mean(H_Pk)\n            #}\n        }\n        #------------------\n        if (\"Fisher alpha\" %in% index) {\n            fish <- try(fisherfit(web)$estimate, silent=TRUE) #in vegan        \n            if (inherits(fish, \"try-error\")) {\n                out$\"Fisher alpha\" <- NA\n            } else {\n                out$\"Fisher alpha\" <- fish\n            }\n        }\n        #----------------------------- evenness & diversity ----------------------\n        if (any(c(\"interaction evenness\", \"Alatalo interaction evenness\", \"Shannon diversity\") %in% index)){\n            # interaction evenness\n            p_i.mat <- web/sum(web)\n            #---------------        \n            SH <- -sum(p_i.mat*log(p_i.mat), na.rm=TRUE)\n            if (\"Shannon diversity\" %in% index) out$\"Shannon diversity\" <- SH\n            IE <- ifelse(intereven==\"prod\", SH/log(prod(dim(web))), SH/log(sum(web>0)))\n            #---------------\n            if (\"interaction evenness\" %in% index) out$\"interaction evenness\" <- IE\n            #---------------\n            if (\"Alatalo interaction evenness\" %in% index){\n            evenness <- function(web){\n                # calculates evenness of the numbers of individual of different species in\n                # a community, NOT according to formula in M√ºller et al. (1999, \n                # J. Anim. Ecol), but according to the original formula in Alatalo \n                # (1981, Oikos) \n                # can be extended at some point to more indices ...\n                pk <- web/sum(web)\n                (Alatalo <- (1/sum(pk^2) -1) / (exp(-sum(pk * log(pk), na.rm=TRUE)) -1))\n            }\n            E <- evenness(web)\n            out$\"Alatalo interaction evenness\" <- E\n            }\n        }      \n        #---------------\n        # Blüthgen's H2'\n        if (\"H2\" %in% index){\n            is.wholenumber <- function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol # from the help of is.integer!\n            if (any(is.wholenumber(web)==FALSE)) H2_integer <- FALSE # turns H2_integer off if values are not integers\n            H2 <- as.numeric(H2fun(web, H2_integer=H2_integer)[1]) #1.element is the standardised H2 prime\n            out$\"H2\"= ifelse(H2<0, 0, H2)\n        }\n        #----------------------- now: grouplevel -------------------\n        # a list of network indices (which should not be called through grouplevel):\n#! JFedit: weighted connectance added here\n        netw.index <- match(c(\"connectance\", \"web asymmetry\", \"links per species\", \"number of compartments\", \"compartment diversity\", \"nestedness\", \"weighted nestedness\", \"weighted NODF\", \"ISA\", \"SA\", \"interaction evenness\", \"Alatalo interaction evenness\", \"Fisher alpha\", \"H2\", \"Shannon diversity\", \"linkage density\", \"weighted connectance\"), index)\n        exclude.index <- netw.index[!is.na(netw.index)]\n        gindex <- if (length(exclude.index)==0) index else index[-exclude.index] # exclude NAs from this vector\n        if (length(gindex) > 0) outg <- grouplevel(web, index=gindex, level=level, weighted=weighted, extinctmethod=extinctmethod, nrep=nrep, CCfun=CCfun, dist=dist, normalise=normalise, empty.web=empty.web, logbase=logbase, fcweighted=fcweighted, fcdist=fcdist)\n        if (exists(\"outg\")){\n            # coerce potential list of HL/LL to one list:\n            if (is.list(outg)){\n                SEQ <- seq(1, 2*length(outg[[1]]), by=2)\n                sorted.outg <- c(outg[[1]], outg[[2]])\n                outg <- sorted.outg[order(c(SEQ, SEQ+1))]\n            } \n            \n            out <- c(unlist(out), outg) \n        } else {out <- unlist(out)} \n    } # end legacy = FALSE      \n    \n    if (legacy == TRUE){ # for the old way of running networklevel\n        out <- .networklevel(web, index=index, ISAmethod=ISAmethod, SAmethod=SAmethod, extinctmethod=extinctmethod, nrep=nrep, plot.it.extinction=FALSE, plot.it.dd=FALSE, CCfun=CCfun, dist=dist, normalise=normalise, empty.web=empty.web, logbase=logbase, fcweighted=fcweighted, fcdist=fcdist)\n        \n    } # end legacy condition\n    \n    return(out)\n}\n\n\n#! JFedit: generality / vs. effective partners etc. NOT changed here! should it be? the changes are not really \"legacy\"?\n.networklevel <- function(web, index=\"ALLBUTDD\", ISAmethod=\"Bluethgen\", SAmethod=\"Bluethgen\", extinctmethod=\"r\", nrep=100, plot.it.extinction=FALSE, plot.it.dd=FALSE, CCfun=median, dist=\"horn\", normalise=TRUE, empty.web=TRUE, logbase=\"e\", intereven=\"sum\", H2_integer=TRUE, fcweighted=TRUE, fcdist=\"euclidean\"){\n    \n    ##\n    ## web         interaction matrix, with lower trophic level in rows, higher in columns\n    ## legacy      se to TRUE allows to run networklevel in its old form\n    \n    if(empty.web) {web <- empty(web)}\n    web.e <- empty(web) # emptied web for some indices \n    if (NROW(web) < 2 | NCOL(web) <2) warning(\"Web is really too small to calculate any reasonable index. You will get the values nonetheless, but I wouldn't put any faith in them!\")\n    \n    allindex <- c( #descriptive:\n        \"number of species\", \"connectance\", \"web asymmetry\", \n        #binary based and related:\n        \"links per species\", \"number of compartments\", \"compartment diversity\",\n        \"cluster coefficient\", \"degree distribution\", \"mean number of shared partners\",\n        \"togetherness\", \"C score\", \"V ratio\", \"discrepancy\", \"nestedness\", \n        \"weighted nestedness\",\n        #miscelleneous:\n        \"ISA\", \"SA\", \"extinction slope\", \"robustness\", \"niche overlap\",   \n        #quantitative series:\n        \"weighted cluster coefficient\", \"weighted NODF\", \"generality\", \"vulnerability\", \"linkage density\", \"Fisher alpha\",  \"interaction evenness\", \"Alatalo interaction evenness\", \"diversity\", \"effective partners\", \"functional diversity\", \"H2\" )\n    \n    # GONE: \"mean interaction diversity\", \n    \n    # only if indices are not given explicitly:\n    if (length(index)==1 & !all(index %in% allindex)){                        \n        index <- switch(index,\n                        \"ALL\" = allindex,\n                        \"ALLBUTDD\" = allindex[-which(allindex==\"degree distribution\")],\n                        \"info\" = c(\"number of species\", \"connectance\", \"web asymmetry\", \"links per species\", \"number of compartments\"),\n                        # logic: only rough information on the network's general structure\n                        \"quantitative\" = c(\"weighted cluster coefficient\", \"weighted nestedness\", \"weighted NODF\", \"functional diversity\", \"H2\", \"diversity\", \"effective partners\", \"mean interaction diversity\", \"linkage density\"),\n                        # logic: the \"quantitative series\"\n                        \"binary\" = c(\"connectance\", \"links per species\", \"nestedness\", \"cluster coefficient\",  \"C-score\"),\n                        # logic: metrics for binary networks\n                        \"topology\" = c(\"connectance\", \"cluster coefficient\", \"degree distribution\", \"togetherness\", \"nestedness\"),\n                        # logic: more abstract, topological metrics for binary networks\n                        stop(\"Your index is not recognised! Typo? Check help for options!\", call.=FALSE) #default for all non-matches\n        )\n    }\n    out <- list()\n\n# set up enough panels for plotting:\nif (plot.it.extinction) {m=2; n=1; par(mfrow=c(m,n), mar=c(5,5,4,1))} else m=1\nif (plot.it.dd) {n=2; par(mfrow=c(m,n), mar=c(5,5,4,1))} else n=1\n\n#-------------------\nif (\"number of species\" %in% index) {\n    out$\"number of lower trophic species\" <- as.integer(NROW(web))\n    out$\"number of higher trophic species\" <- as.integer(NCOL(web))\n}\n#--------------------\nif (\"connectance\" %in% index){\n    # connectance: \"the fraction of all possible links that are realized in a network\", (p. 12917 in Dunne et al. 2002)\n    out$connectance <- sum(web>0)/prod(dim(web))\n}\n#--------------------\nif (\"web asymmetry\" %in% index) out$\"web asymmetry\" <- (NCOL(web)-NROW(web))/sum(dim(web))     # web asymmetry (Bl√ºthgen et al. 2007, Fig. S2)\n###---###---###---###---###---###---###---###---###---###---###---###---###\n#--------------------\nif (\"links per species\" %in% index){\n    L <- sum(web>0)/sum(dim(web))\n    out$\"links per species\"=L\n}\n#--------------------\nif (any(c(\"number of compartments\", \"compartment diversity\") %in% index)){\n    CD <- function(co){\n        if (co$n.compart>1){\n            no <- NA\n            for (i in 1:co$n.compart){\n                comp <- which(abs(co$cweb)==i, arr.ind=TRUE) # who is in a compartment?\n                no[i] <- length(unique(comp[,1])) + length(unique(comp[,2])) # how many species\n            }\n            no <- no/sum(dim(web)) # standardise for number of species in the web\n            CD <- exp(-sum(no*log(no)))\n        }  else {CD <- NA} #; warning(\"only one compartment\")}\n        CD\n    }\n    \n    comps <- try(compart(web.e), silent=TRUE)\n    if (class(comps)==\"try-error\") {\n        ncompart <- compdiv <- NA\n    } else  {\n        ncompart <- comps$n.compart\n        compdiv <- CD(comps)\n    }\n    if (\"number of compartments\" %in% index) out$\"number of compartments\" <- as.integer(ncompart)\n    if (\"compartment diversity\" %in% index) out$\"compartment diversity\" <- compdiv\n}\n#------------------------\nif (\"cluster coefficient\" %in% index){\n    cluster.coef <- function(web, full=FALSE, FUN=mean){\n        # calculate cluster coefficient\n        # web   a bipartite web\n        # full  logical; return cluster coefficients for each species in the network?\n        # FUN   give a function to summarise individual cluster coefficients, defaults to 'mean'.\n        # The concept was introduced by Watts & Strogatz (1998) and is described under in Wikipedia under http://en.wikipedia.org/w/index.php?title=Clustering_coefficient\n        # Its main idea was to help identifying small-world networks, which should\n        # have high cluster coefficients but low path lengths.\n        # Ci of species i is simply the number of realised links devided by the number of possible links. At the network level, the CC for a network is the average CC of its members. This is a little bit fishy, since the CCs are log-normal\n        # distributed (in pollinations networks at least). Therefore with FUN also\n        # other summary measures can be employed.\n        # Because within 'bipartite' we look at 2-mode networks, mean C is:\n        # C_lowertrophiclevel = C_highertrophiclevel = C_entirenetwork.\n        #\n        # Literature: Watts DJ, Strogatz S (1998) Collective dynmics of 'small-world' networks. Nature 393:440-442\n        \n        # notice that this CC differs from the binary version of Tore Opsahl's. This here is the same as the one-mode cluster coefficient, Tore's is the \"corrected\" two-mode!\n        web <- as.matrix(web)\n        Ci.high <- colSums((web>0))/nrow(web)\n        Ci.low <- rowSums((web>0))/ncol(web)\n        CC <- FUN(Ci.high)\n        if (full) out <- list(\"cluster coefficient\"=CC, \"CC values higher\"=Ci.high,\n                              \"CC values lower\"=Ci.low) else out <- c(\"cluster coefficient\"=CC)\n        out\n    }\n    out$\"cluster coefficient\"=as.numeric(cluster.coef(web, FUN=CCfun, full=FALSE))\n}\n\nif (\"weighted cluster coefficient\" %in% index){  \n    # compute the weighted cluster coefficient using tnet:\n    edgelist <- web2edges(web, return=TRUE)\n    wcc <- try(unname(clustering_tm(edgelist)[\"am\"]), silent=TRUE) #uses arithmetic mean!\n    out$\"weighted cluster coefficient\" <- if (inherits(wcc, \"try-error\")) \"NA\" else wcc\n}\n\n#--------------------------\n# degree distribution fits:\nif (\"degree distribution\" %in% index){\n    dd <- suppressWarnings(try(degreedistr(web, plot.it=plot.it.dd, pure.call=FALSE), silent=TRUE))\n    if (class(dd)==\"try-error\"){\n        dd <- list()\n        dd$\"dd fits LTL\" <- NA\n        dd$\"dd fits HTL\" <- NA\n    }\n    out$\"degree distribution LTL\" <- dd$\"dd fits LTL\"\n    out$\"degree distribution HTL\" <- dd$\"dd fits HTL\"\n}\n#-------------------\n# The Stone & Roberts's indices: S, T and C score:\n#-------------------\nif (\"mean number of shared partners\" %in% index) {\n    out$\"mean number of shared HTL species\" <- \n        mean(designdist(t(web)>0, method=\"J\", terms=\"minimum\"))\n    out$\"mean number of shared LTL species\" <- \n        mean(designdist(web>0, method=\"J\", terms=\"minimum\"))\n} \n#-------------------\nif (\"togetherness\" %in% index){\n    out$togetherness <- togetherness(web, normalise=normalise, na.rm=TRUE)\n}\n#-------------------\nif (\"C score\" %in% index){\n    out$\"C score\" <- C.score(web, normalise=normalise, na.rm=TRUE)\n}\n\n#-------------------\nif (\"V ratio\" %in% index){\n    out$\"V ratio\" <- V.ratio(web)\n}\n#-------------------\nif (\"discrepancy\" %in% index){\n    out$discrepancy <- as.integer(unname(discrepancy(web)))\n}\n#-------------------\nif (\"nestedness\" %in% index){\n    nest <- try(nestedtemp(web)$statistic, silent=TRUE)\n    out$nestedness <- ifelse(class(nest)==\"try-error\", NA, nest)\n    # a fast implementation of nestedness by Jari Oksanen\n    #old: nestedness(web, null.models=FALSE)$temperature\n}\n#-------------------\nif (\"weighted nestedness\" %in% index){\n    wine.res <- try(wine(web.e, nreps=nrep)$wine, silent=TRUE)\n    out$\"weighted nestedness\" <- if (!inherits(wine.res, \"try-error\")) {wine.res} else {NA}\n}\n#-------------------\nif (\"weighted NODF\" %in% index){\n    out$\"weighted NODF\" <- unname(nestednodf(web, order=TRUE, weighted=TRUE)$statistic[3])\n}\n\n###---###---###---###---###---###---###---###---###---###---###---###---###\nif (\"ISA\" %in% index){#(any(c(\"ISA\", \"interaction strength asymmetry\", \"dependence asymmetry\")) %in% index){\n    # Dependence asymmetry (Bascompte et al. 2006; Blüthgen et al. 2007, Fig. S2)\n    depL <- web.e/matrix(rowSums(web.e), nrow=NROW(web.e), ncol=NCOL(web.e), byrow=FALSE)\n    depH <- web.e/matrix(colSums(web.e), nrow=NROW(web.e), ncol=NCOL(web.e), byrow=TRUE)\n    \n    if (ISAmethod==\"Bascompte\" & \"ISA\" %in% index) {\n        #depMax <- depL\n        #greaterindex <- depL < depH\n        #depMax[greaterindex] <- depH[greaterindex]\n        \n        out$\"dependence asymmetry\"=mean(abs(depL-depH)/pmax(depL, depH), na.rm=TRUE)\n    }\n    if (ISAmethod==\"Bluethgen\" & \"ISA\" %in% index) {\n        web2 <- web\n        # delete cells for species encountered only once (Blüthgen, pers. comm.):\n        web2[, which(colSums(web)==1)] <- 0\n        web2[which(rowSums(web)==1), ] <- 0\n        rowsummat <- matrix(rowSums(web2), nrow=NROW(web2), ncol=NCOL(web2), byrow=FALSE)\n        colsummat <- matrix(colSums(web2), nrow=NROW(web2), ncol=NCOL(web2), byrow=TRUE)\n        depL <- web2/rowsummat\n        depH <- web2/colsummat\n        \n        depL[depL<=0] <- NA\n        depH[depH<=0] <- NA\n        # now we need a correction to account for the fact that links with few (e.g. 2) observations will have a minimum depL of 1/2: all on one species: depL=1, one on each of two: depL=0.5\n        depLprime <- (depL - 1/rowsummat)/(1 - 1/rowsummat) \n        # assumes depLmin = 1/web2 and depLmax=1\n        depHprime <- (depH - 1/colsummat)/(1 - 1/colsummat)\n        \n        out$\"interaction strength asymmetry\"=mean(as.matrix(depHprime-depLprime), na.rm=TRUE) #ranges from -1 to 1 /sum(depLprime, depHprime, na.rm=TRUE)\n    }\n}\n\n#---------------------------------------------------------\n# Specialisation asymmetry (Bl¸thgen et al. 2007, Fig. S2)\n# 2 options for calculating the \"mean\" SA:\n# either as Bl¸thgen et al: average weighted by number of interactions in the \n# cell or as mean of logarithms (since the dependencies follow a lognormal\n# distribution)\nif (\"SA\" %in% index){#(any(c(\"SA\", \"specialisation asymmetry\")) %in% index){\n    di <- dfun(web)$dprime  # plants\n    dj <- dfun(t(web))$dprime # pollinators\n    if (SAmethod==\"log\"){\n        lgmeani <- mean(log(di[di>0])); lgmeanj <- mean(log(dj[dj>0]))\n        SA <- (lgmeanj-lgmeani)/sum(lgmeani, lgmeanj)  \n        # ij-sequence changed because log changes sequence, too\n    }\n    if (SAmethod==\"Bluethgen\"){\n        wmeani <- sum(di*rowSums(web.e))/sum(web.e)\n        wmeanj <- sum(dj*colSums(web.e))/sum(web.e)\n        SA <- (wmeanj-wmeani)/sum(wmeani, wmeanj) \n        # positive values indicate more specialisation in the higher trophic level\n    }\n    out$\"specialisation asymmetry\" <- SA \n}\n\n#--------------------------\n# species extinction curve:\nif (any(c(\"extinction slope\", \"robustness\") %in% index)){\n    extL <- try(second.extinct(web=web, method=extinctmethod, nrep=nrep, participant=\"lower\"), silent=TRUE)       \n    extH <- try(second.extinct(web=web, method=extinctmethod, nrep=nrep, participant=\"higher\"), silent=TRUE)\n    if (\"extinction slope\" %in% index){\n        slopeL <- try(slope.bipartite(extL, col=\"green\", pch=16, type=\"b\", plot.it=plot.it.extinction), silent=TRUE)\n        out$\"extinction slope LTL\"=suppressWarnings(as.numeric(slopeL))            \n        \n        slopeH <- try(slope.bipartite(extH, col=\"green\", pch=16, type=\"b\", plot.it=plot.it.extinction), silent=TRUE)\n        out$\"extinction slope HTL\"=suppressWarnings(as.numeric(slopeH))\n    }\n    \n    if (\"robustness\" %in% index) {\n        if (inherits(extL, \"try-error\")){\n            robustL <- robustH <- NA\n        } else {\n            robustL <- try(robustness(extL), silent=TRUE)\n            robustH <- try(robustness(extH), silent=TRUE)\n            \n            rL <- if (inherits(robustL, \"try-error\")) NA else robustL\t\t  \n            rH <- if (inherits(robustH, \"try-error\")) NA else robustH\t\t  \n        }\n        out$\"robustness higher exterminated\" = as.numeric(rH)\n        out$\"robustness lower exterminated\" = as.numeric(rL)\n    }\n}\n#--------------------------\n# mean similarity of niches (niche overlap, sensu Krebs, Ecological Methodology)\n# vegdist demands \"sites\" to be in rows, therefore the web has to be transposed\n# to calculate dissimilarity between higher level species; similarity is simply\n# 1-dissimilarity:\nif (\"niche overlap\" %in% index) {\n    NOhigher <- mean(1-vegdist(t(web.e), method=dist))\n    NOlower <- mean(1-vegdist(web.e, method=dist))\n    out$\"niche overlap LTL\" <- NOlower\n    out$\"niche overlap HTL\" <- NOhigher\n}\n###---###---###---###---###---###---###---###---###---###---###---###---###\nif (any(c(\"links per species\", \"linkage density\", \"vulnerability\", \"generality\", \"Fisher alpha\", \"mean interaction diversity\") %in% index)){\n    # for formula see Tylianakis et al. (2006), supplement.\n    # N refers to prey, P to predators\n    \n    preytot.mat <- matrix(rep(colSums(web), NROW(web)), NROW(web), byrow=TRUE)\n    preyprop.mat <- web/preytot.mat  # = b_ik/b_.k in the first formula\n    #H_Nk is the diversity index of inflow (diversity of flower visits for each pollinator)\n    predtot.mat <- matrix(rep(rowSums(web), NCOL(web)), NROW(web), byrow=FALSE)\n    predprop.mat <- web/predtot.mat  # = b_kj/b_.k in the second formula\n    \n    if (logbase==2 | logbase==\"2\"){\n        H_Nk <- apply(preyprop.mat, 2, function(x) -sum(x*log2(x), na.rm=TRUE))\n        #H_Pk is the diversity index of pollinators for each plant species\n        H_Pk <- apply(predprop.mat, 1, function(x) -sum(x*log2(x), na.rm=TRUE))\n        # next, we need the reciprocals of this\n        # note that the ifelse is only needed if the web contains prey that is\n        # not eaten or predators that don't eat ...\n        n_Nk <- ifelse(colSums(web)!=0, 2^H_Nk, 0)\n        n_Pk <- ifelse(rowSums(web)!=0, 2^H_Pk, 0)\n    }\n    if (logbase==\"e\"){ # same code as above, just with \"e\"\n        H_Nk <- apply(preyprop.mat, 2, function(x) -sum(x*log(x), na.rm=TRUE))\n        H_Pk <- apply(predprop.mat, 1, function(x) -sum(x*log(x), na.rm=TRUE))\n        n_Nk <- ifelse(colSums(web)!= 0, exp(H_Nk), 0)\n        n_Pk <- ifelse(rowSums(web)!= 0, exp(H_Pk), 0)\n    }\n    # mean number of predators per prey\n    V <- sum(rowSums(web)/sum(web)*n_Pk)\n    # marginal totals-weighted mean exp(Shannon diversity)\n    G <- sum(colSums(web)/sum(web)*n_Nk)\n    # linkage density\n    LD_q <- 0.5*(V+G)\n    if (\"vulnerability\" %in% index) out$\"vulnerability\" <- V\n    #------------------\n    if (\"generality\" %in% index) out$\"generality\"=G\n    #------------------\n    if (\"linkage density\" %in% index) out$\"linkage density\"=LD_q\n    #LD_qs <- LD_q/(NROW(web)+NCOL(web)) # \"weighted food web connectance\", according to Jason's appendix\n    #------------------\n    if (\"Fisher alpha\" %in% index) {\n        fish <- try(fisherfit(web)$estimate, silent=TRUE) #in vegan        \n        if (inherits(fish, \"try-error\")) {\n            out$\"Fisher alpha\" <- NA\n        } else {\n            out$\"Fisher alpha\" <- fish\n        }\n    }\n    #------------------\n    # #We found no reference to this metric and saw little use for it. It is very similar to vulnerability/generality and can easily be computed from the output of \\code{\\link{specieslevel}} as \\code{mean(specieslevel(web, index=\"diversity\"))}        \n    # if (\"mean interaction diversity\" %in% index){\n    # out$\"interaction diversity LTL\" <- mean(H_Nk)\n    # out$\"interaction diversity HTL\" <- mean(H_Pk)\n    #}\n}\n#----------------------------- evenness & diversity ----------------------\nif (any(c(\"interaction evenness\", \"Alatalo interaction evenness\", \"Shannon diversity\") %in% index)){\n    # interaction evenness\n    p_i.mat <- web/sum(web)\n    SH <- -sum(p_i.mat*log(p_i.mat), na.rm=TRUE)\n    IE <- ifelse(intereven==\"prod\", SH/log(prod(dim(web))), SH/log(sum(web>0)))\n    #---------------\n    if (\"interaction evenness\" %in% index) out$\"interaction evenness\" <- IE\n    #---------------\n    if (\"Alatalo interaction evenness\" %in% index){\n        evenness <- function(web){\n            # calculates evenness of the numbers of individual of different species in\n            # a community, NOT according to formula in M√ºller et al. (1999, \n            # J. Anim. Ecol), but according to the original formula in Alatalo \n            # (1981, Oikos) \n            # can be extended at some point to more indices ...\n            pk <- web/sum(web)\n            (Alatalo <- (1/sum(pk^2) -1) / (exp(-sum(pk * log(pk), na.rm=TRUE)) -1))\n        }\n        \n        E <- evenness(web)\n        out$\"Alatalo interaction evenness\" <- E\n    }    \n    #---------------        \n    if (\"Shannon diversity\" %in% index) out$\"Shannon diversity\" <- SH    \n    \n}\n#---------------\n# Devoto's fd:\n#! JFedit: changed fd to fc here (but only the function and arguments because in legacy function; this may not be the best decision)\nif (any(c(\"fd\", \"functional diversity\") %in% index)){\n    out$\"Functional diversity LTL\" <- fc(t(web), dist=fcdist, method=\"average\", weighted=fcweighted)\t\t\n    out$\"Functional diversity HTL\" <- fc(web, dist=fcdist, method=\"average\", weighted=fcweighted)\n}\n\n#---------------\n# Blüthgen's H2'\nif (\"H2\" %in% index){\n    is.wholenumber <- function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol # from the help of is.integer!\n    if (any(is.wholenumber(web)==FALSE)) H2_integer <- FALSE # turns H2_integer off if values are not integers\n    H2 <- as.numeric(H2fun(web, H2_integer=H2_integer)[1]) #1.element is the standardised H2 prime\n    out$\"H2\"= ifelse(H2<0, 0, H2)\n}\n\n#---------------------------------------------------------------------------\nif (!(\"degree distribution\" %in% index)) out <- unlist(out)\n    \nreturn(out)\n    \n}\n\n\n#networklevel(Safariland, index=\"H2\", legacy=F)\n#networklevel(Safariland, index=\"ALLBUTDD\", legacy=F)\n#networklevel(Safariland, index=c(\"Alatalo interaction evenness\", \"H2\"), legacy=F)\n#networklevel(Safariland, index=c(\"extinction slope\", \"Alatalo interaction evenness\", \"H2\"), legacy=F)\n#networklevel(Safariland, index=c(\"H2\", \"degree distribution\" ,\"ISA\", \"SA\", \"clustering coefficient\", \"partner diversity\"))\n#networklevel(Safariland, index=c(\"H2\", \"extinction slope\" ,\"ISA\", \"SA\", \"cluster coefficient\", \"partner diversity\", \"diversity\"))\n#networklevel(Safariland, index=\"ALL\")\n#networklevel(Safariland, index=c(\"ISA\", \"SA\"), level=\"both\", weighted=FALSE)\n#networklevel(Safariland,level=\"higher\")",
    "created" : 1383969203549.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3052987771",
    "id" : "3311F4B0",
    "lastKnownWriteTime" : 1384102000,
    "path" : "C:/DATEN_arbeit/Dropbox/_SharedFolders/Carsten/bipartite/R/networklevel.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}