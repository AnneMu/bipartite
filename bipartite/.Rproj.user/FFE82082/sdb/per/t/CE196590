{
    "contents" : "grouplevel <- function(web, index=\"ALLBUTDD\", level=\"both\", weighted=TRUE, empty.web=FALSE, dist=\"horn\", CCfun=mean, logbase=\"e\", normalise=TRUE,  extinctmethod=\"r\", nrep=100, fcdist=\"euclidean\", fcweighted=TRUE){\n    if (level == \"both\")   for.higher <- for.lower <- TRUE\n    if (level == \"higher\") {for.higher <- TRUE; for.lower=FALSE}\n    if (level == \"lower\")  {for.lower  <- TRUE; for.higher=FALSE}\n    \n     if (\"vulnerability\" %in% index & level == \"higher\") warning(\"You requested 'vulnerability' for the higher level, although it is not a higher level index! You will get 'generality' instead (same thing, really).\", call.=FALSE)\n      if (\"generality\" %in% index & level == \"lower\") warning(\"You requested 'generality' for the lower level, although it is not a lower level index! You will get 'vulnerability' instead (same thing, really).\", call.=FALSE)\n    \n    \n    if (for.higher) outh <- one.grouplevel(web, level=\"higher\", index=index, weighted=weighted, empty.web=empty.web, dist=dist, CCfun=CCfun, logbase=logbase, normalise=normalise, extinctmethod=extinctmethod, nrep=nrep, fcdist=fcdist, fcweighted=fcweighted)\n\n    if (for.lower) outl <- one.grouplevel(web, level=\"lower\", index=index, weighted=weighted, empty.web=empty.web, dist=dist, CCfun=CCfun, logbase=logbase, normalise=normalise, extinctmethod=extinctmethod, nrep=nrep, fcdist=fcdist, fcweighted=fcweighted)\n    \n    if (level == \"higher\") return(outh)\n    if (level == \"lower\")  return(outl)\n    if (!(\"degree distribution\" %in% index)) {\n        out <- c(outh, outl)\n        SEQ <- seq(1, length(out), by=2)\n        out <- out[order(c(SEQ, SEQ+1))] # that needed some hard thinking, getting those bloody numbers align properly ...\n    }\n    \n    if (level == \"both\"){\n        if (!(\"degree distribution\" %in% index)) {\n            out <- c(outh, outl)\n            SEQ <- seq(1, length(out), by=2)\n            out <- out[order(c(SEQ, SEQ+1))] # that needed some hard thinking, getting those bloody numbers align properly ...\n        } else {out <- list(\"HL\"=outh, \"LL\"=outl)}\n        return(out) # leave all the naming issues to function one.grouplevel\n    }\n}\n\n\n\none.grouplevel <- function(web, index=\"ALLBUTDD\", level=\"higher\", weighted=TRUE, empty.web=FALSE, dist=\"horn\", CCfun=mean, logbase=\"e\", normalise=TRUE, extinctmethod=\"r\", nrep=100, fcdist=\"euclidean\", fcweighted=TRUE){\n  ### computes indices for one group level (i.e. higher/lower trophic level)\n  \n  web <- as.matrix(web)   \n\n  ######\n  if (level == \"lower\") web <- t(web)\n  ######\n  \n  if(empty.web) {web <- empty(web)}\n  web.e <- empty(web) # emptied web for some indices \n  if (NROW(web) < 2 | NCOL(web) <2) warning(\"Web is really too small to calculate any reasonable index. You will get the values nonetheless, but I wouldn't put any faith in them!\")\n                \n   allindex <- c( \"number of species\", \"mean number of links\", \"mean number of shared partners\",\n           \"cluster coefficient\", \"degree distribution\", \"niche overlap\",\n           \"togetherness\", \"C score\", \"V ratio\", \"discrepancy\", \"extinction slope\", \"robustness\",    \n           #quantitative series:\n#! JFedit: effective partners removed here; do we really have fd and fc?; probably needs some work throughout\n          \"weighted cluster coefficient\", \"generality\", \"vulnerability\", \"partner diversity\", \"functional diversity\", \"functional complementarity\")         \n           # GONE: \"mean interaction diversity\", \"effective partners\" [syn. with generality/vulnerability, name still allowed],\n  \n       # only if indices are not given explicitly:\n       if (length(index) == 1 & !all(index %in% allindex)){                        \n       index <- switch(index,\n               \"ALL\" = allindex,\n               \"ALLBUTDD\" = allindex[-which(allindex==\"degree distribution\")],\n               stop(\"Your index is not recognised! Typo? Check help for options!\", call.=FALSE) #default for all non-matches\n               )\n           }\n  \n           \n  # compute weights: sum of observed interactions per species (i.e., a list of 2)\n  if (weighted){\n    Wl <- apply(web, 1, sum)/sum(web)\n    Wh <- apply(web, 2, sum)/sum(web)\n  } else {\n    Wl <- rep(1, NROW(web))\n    Wh <- rep(1, NCOL(web))\n  }\n   \n  out <- list()\n    \n  if (!(level %in% c(\"higher\", \"lower\"))) stop(\"Please choose a valid level: 'higher' or 'lower'.\")    \n  \n  ######################### computations for both levels ##########################\n  \n  # mean partner diversity\n  if (any(c(\"partner diversity\", \"effective partners\", \"generality\", \"vulnerability\") %in% index)){\n      preytot.mat <- matrix(rep(colSums(web), NROW(web)), NROW(web), byrow=TRUE)\n      preyprop.mat <- web/preytot.mat  # = b_ik/b_.k in the first formula\n      #H_Nk is the diversity index of inflow (diversity of flower visits for each pollinator)\n      predtot.mat <- matrix(rep(rowSums(web), NCOL(web)), NROW(web), byrow=FALSE)\n      predprop.mat <- web/predtot.mat  # = b_kj/b_.k in the second formula\n      if (logbase==2 | logbase==\"2\"){\n        H_Nk <- apply(preyprop.mat, 2, function(x) -sum(x*log2(x), na.rm=TRUE))\n        #H_Pk is the diversity index of pollinators for each plant species\n        H_Pk <- apply(predprop.mat, 1, function(x) -sum(x*log2(x), na.rm=TRUE))\n        # next, we need the reciprocals of this\n        # note that the ifelse is only needed if the web contains prey that is\n        # not eaten or predators that don't eat ...\n        n_Nk <- ifelse(colSums(web)!=0, 2^H_Nk, 0)\n        n_Pk <- ifelse(rowSums(web)!=0, 2^H_Pk, 0)\n      }\n      if (logbase==\"e\"){ # same code as above, just with \"e\"\n        H_Nk <- apply(preyprop.mat, 2, function(x) -sum(x*log(x), na.rm=TRUE))\n        H_Pk <- apply(predprop.mat, 1, function(x) -sum(x*log(x), na.rm=TRUE))\n        n_Nk <- ifelse(colSums(web)!= 0, exp(H_Nk), 0)\n        n_Pk <- ifelse(rowSums(web)!= 0, exp(H_Pk), 0)\n      }\n  }  \n   \n   # degree distribution fits:\n   if (\"degree distribution\" %in% index){\n        dd <- suppressWarnings(try(degreedistr(web, plot.it=FALSE, pure.call=FALSE), silent=TRUE))\n   }\n             \n  ###### for the higher level ######\n  \n    if (\"number of species\" %in% index) {\n      spH <- c(\"number of species\"=NCOL(web))\n      out$\"number of species\" <- spH\n    }\n    \n    ### 1. indices aggregated from individual species using mean or weighted.mean  #############\n    \n    # mean number of links\n    if (\"mean number of links\" %in% index) {\n      out$\"mean number of links\" <- weighted.mean(colSums(web>0), w=Wh)\n    }\n\n    if (\"mean number of shared partners\" %in% index) {\n      # NO WEIGHTING HERE, since it works on distances between species.\n      out$\"mean number of shared partners\"  <- mean(designdist(t(web)>0, method=\"J\", terms=\"minimum\"))     # HL\n    }\n    \n    # cluster coefficient:\n    if (\"cluster coefficient\" %in% index){\n        Ci.high <- colSums((web>0))/nrow(web)\n        out$\"cluster coefficient\" <- weighted.mean(Ci.high, w=Wh)\n    }\n    \n    if (\"weighted cluster coefficient\" %in% index){  \n        # compute the weighted cluster coefficient using tnet:\n        edgelist <- web2edges(web, return=TRUE)\n        wcc <- try(unname(clustering_tm(edgelist)[\"am\"]), silent=TRUE) #uses arithmetic mean!\n        out$\"weighted cluster coefficient\" <- if (inherits(wcc, \"try-error\")) \"NA\" else wcc\n    }\n    \n    # mean niche overlap\n    # mean similarity of niches (niche overlap, sensu Krebs, Ecological Methodology)\n    # vegdist demands \"sites\" to be in rows, therefore the web has to be transposed\n    # to calculate dissimilarity between higher level species; similarity is simply\n    # 1-dissimilarity:\n    if (\"niche overlap\" %in% index) { # no weighting!\n      NOhigher <- mean(1-vegdist(t(web.e), method=dist))\n      out$\"niche overlap\" <- NOhigher\n    }  \n\n  # togetherness (not symmetric)\n  if (\"togetherness\" %in% index){\n    out$\"togetherness\" <- togetherness(web, normalise=normalise, na.rm=TRUE)\n  }\n  \n  # C.score (not symmetric)\n  if (\"C score\" %in% index){\n  \tCS <- try(C.score(web, normalise=normalise, na.rm=TRUE), silent=TRUE)\n    out$\"C score\" <- if (inherits(CS, \"try-error\")) NA else CS\n  }\n  \n  # V.ratio (not symmetric)\n  if (\"V ratio\" %in% index){\n    out$\"V ratio\" <- V.ratio(web)\n  }\n  \n  # discrepancy (not symmetric)\n  if (\"discrepancy\" %in% index){\n    out$discrepancy <- as.integer(unname(discrepancy(web)))\n  }\n\n  # degree distribution fits:\n  if (\"degree distribution\" %in% index){\n    if (class(dd)==\"try-error\"){\n      print(\"Panic!\")\n      dd <- list()\n      dd[[2]] <- NA\n    }\n    out$\"degree distribution\" <- dd[[2]] # HTL\n  }\n  # secondary extinction slope (not symmetric)\n  if (any(c(\"extinction slope\", \"robustness\") %in% index)){\n    extL <- try(second.extinct(web=web, method=extinctmethod, nrep=nrep, participant=\"lower\"), silent=TRUE)       \n    if (\"extinction slope\" %in% index){\n      slopeH <- try(slope.bipartite(extL, col=\"green\", pch=16, type=\"b\", plot.it=FALSE), silent=TRUE)\n      out$\"extinction slope\"=suppressWarnings(as.numeric(slopeH))            \n    }\n    \n    if (\"robustness\" %in% index) {\n      if (inherits(extL, \"try-error\")){\n        robustH <- NA\n      } else {\n        robustH <- try(robustness(extL), silent=TRUE)                \n      }\n      rH <- if (inherits(robustH, \"try-error\")) NA else robustH          \n      out$\"robustness\" = as.numeric(rH)\n    }\n  }\n  # Devoto's fd:\n#! JFedit: fd changed to fc here (also fddist and fdweighted replaced throughout script); old: \"functional diversity\", \n  if (any(c(\"fc\", \"functional complementarity\") %in% index)){   \n    out$\"functional complementarity\" <- fc(t(web), dist=fcdist, method=\"average\", weighted=fcweighted)\n  }\n      \n    # diversity:\n    if (\"partner diversity\" %in% index){\n      out$\"partner diversity\" <- weighted.mean(H_Nk, w=Wh)\n    }\n\n#! JFedit: effective partners and generality/vulnerability now reduced to one index (before, they differed because only effective partners responded to \"weighted\")  \n  # effective number of partners:\n  if (any(c(\"generality\", \"vulnerability\", \"effective partners\") %in% index)){\n    G <- weighted.mean(n_Nk, w=Wh)\n    if (level == \"higher\") out$generality <- G\n    if (level == \"lower\") out$vulnerability <- G\t\n  }\n      \n      #  if (any(c(\"generality\", \"vulnerability\") %in% index)){     \n      #    # for weighted=T, this should be the same as G:\n      #    # marginal totals-weighted mean exp(Shannon diversity)\n      #    G <- sum(colSums(web)/sum(web)*n_Nk)\n      #    \n      #    if (level == \"higher\") out$generality <- G \n      #    if (level == \"lower\") out$vulnerability <- G\n      #  }    \n  \n  \n  ################ NOT included #################\n  # PDI (no interpretation at group level)\n  # PSI (no interpretation at group level)\n  # NSI (no interpretation at group level)\n  # betweenness, closeness (no interpretation at group level)\n  # Fisher alpha (no interpretation at group level)\n\n           \n    #---------------------------------------------------------------------------\n           \n    if (level == \"higher\") names(out) <- paste(names(out), \".HL\", sep=\"\")\n    if (level == \"lower\") names(out) <- paste(names(out), \".LL\", sep=\"\")\n    \n    if (!(\"degree distribution\" %in% index)) {\n      out <- unlist(as.data.frame(out))\n      rownames(out) <- NULL\n    }\n  \n    return(out)\n           \n}\n\n# memmott takes ages!\n#grouplevel(Safariland, level=\"both\")\n#grouplevel(Safariland, level=\"lower\")\n#grouplevel(Safariland, index=\"ALLBUTDD\", level=\"lower\")\n#grouplevel(Safariland, index=\"degree distribution\", level=\"lower\")\n#grouplevel(Safariland, index=\"degree distribution\", level=\"both\")\n#grouplevel(Safariland, index=\"ALLBUTDD\", level=\"higher\", weighted=FALSE)\n# outh <- one.grouplevel(Safariland, index=\"degree distribution\", level=\"higher\", weighted=FALSE)\n#grouplevel(Safariland, index=\"extinction slope\", level=\"lower\")\n#grouplevel(Safariland, index=c(\"degree distribution\"))\n#grouplevel(Safariland, index=\"ALL\")\n#grouplevel(Safariland, index=\"generality\", level=\"higher\")",
    "created" : 1383966861075.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3187930670",
    "id" : "CE196590",
    "lastKnownWriteTime" : 1384101631,
    "path" : "C:/DATEN_arbeit/Dropbox/_SharedFolders/Carsten/bipartite/R/grouplevel.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}