{
    "contents" : "# `specieslevel` \nspecieslevel <-\nfunction(web, index=\"ALLBUTD\", level=\"both\", logbase=exp(1), low.abun=NULL, high.abun=NULL, PDI.normalise=TRUE, PSI.beta=c(1,0), nested.method=\"NODF\", nested.normalised=TRUE, nested.weighted=TRUE, empty.web=TRUE) {\n    # function to calculate bipartite web indices at the species level\n    #\n    # Carsten Dormann, Jochen Fründ & Denis Lippok, April/May 2007 - 2013\n\n\n    # m <- matrix(c(4,7,0,0,9,1,2,0,5), 3, byrow=TRUE)\n    if (!is.numeric(logbase)) stop(\"logbase must be numeric, e.g. 2 or exp(1) or 10!\")\n\n#! JFedit: we need an option empty.web just as in networklevel\n  # must still be checked for case empty.web=FALSE (web.e not yet used anywhere)\n    if(empty.web) {web <- empty(web)}   # delete unobserved species\n    if(empty.web==FALSE) warning(\"empty.web=FALSE not yet supported in specieslevel\")\n    web.e <- empty(web) # emptied web for some indices \n\n    allindex <- c(\"degree\", \"normalised degree\", \"species strength\", \"nestedrank\", \"interaction push pull\", \"PDI\", \"resource range\", \"species specificity\", \"PSI\", \"NSI\", \"betweenness\", \"closeness\", \"Fisher alpha\", \"partner diversity\", \"effective partners\", \"d\", \"dependence\", \"proportional generality\", \"proportional similarity\")\n  #JFedit:\n      # added \"proportional similarity\" (or PS), \"proportional generality\" (or \"effective resource range\" or \"effective proportional resource use\")\n      # note that proportional generality can be higher than 1, (when a species selects for diversity)\n#! JFedit: synonyms e.g. \"paired differences index\" only work if there is also an index name from the list above\n\n    if (\"ALL\" %in% index) index <- allindex\n    if (\"ALLBUTD\" %in% index) index <- allindex[-which(allindex==\"dependence\")]\n    #out <- list()\n    \n    # only if indices are not given explicitly:\n    if (length(index) == 1 & !all(index %in% allindex)){                        \n    \tindex <- switch(index,\n        \t\"ALL\" = allindex,\n        \t\"ALLBUTD\" = allindex[-which(allindex==\"dependence\")],\n         \tstop(\"Your index is not recognised! Typo? Check help for options!\", call.=FALSE) #default for all non-matches\n          )\n    }\n    \n    # catch cases where an invalid index is demanded:\n    if (length(which(!(index %in% allindex))) > 0) warning(paste0(\"Index '\", index[which(!(index %in% allindex))], \"' not recognised and hence not computed!\"))\n    \n    higher.out <- list()\n    lower.out <- list()\n\n    # sort out which level to compute indices for:\n    if (level == \"both\") {for.higher <- TRUE; for.lower <- TRUE}\n    if (level == \"higher\") {for.higher <- TRUE; for.lower <- FALSE}\n    if (level == \"lower\") {for.higher <- FALSE; for.lower <- TRUE}\n    if (!(level %in% c(\"both\", \"higher\", \"lower\"))) stop(\"Please choose a valid level: 'both', 'higher' or 'lower'.\")    \n    \n    \n    # !!!!!! functions are split up over higher and lower level computations !!!!!!\n    \n    ############## helper functions (alphabetically) ########################\n    \n    BCC_weighted <- function(web, method=\"sum\", level=\"higher\", index=\"betweenness\"){\n      # computes weighted betweenness as proportion of shorted paths through this species\n      # notice that these results are identical to the function \"BC\" when using binary data (web>)!\n      # In weighted networks, some paths are actually LOST!\n      #\n      # Will return a warning when web is comparted!\n      \n      if (level == \"higher\") web <- t(web) \n      CO <- compart(web)\n      \n      if (CO$n.compart >= sum(web>0)){\n        # projection fails when all species have their own compartment!\n        out <- rep(NA, NCOL(web))\n        return(out)\n      }\n          \n      el <- web2edges(web, return=TRUE)\n      # el <- symmetrise_w(el) # needed for undirected webs\n      suppressWarnings(proj <- projecting_tm(el, method=method) )\n      if (any(dim(proj) < 2)){\n          warning(\"Web contains too few nodes to compute closeness or betweenness!\")\n          return(rep(NA, NROW(web))) # closeness/betweenness cannot be computed with only one link!\n      } \n      \n      if (index == \"betweenness\") {\n        b <- betweenness_w(proj)[,2]\n        if (length(b) != NROW(web)){\n          b <- c(b, rep(NA, (NROW(web) - length(b))))\n        }\n        if (!is.null(rownames(web))) names(b) <- rownames(web)\n        if (sum(b, na.rm=TRUE) == 0) out <- b else out <- b/sum(b, na.rm=TRUE)\n      }\n      \n      if (index == \"closeness\") {\n        ## closeness returns only the larger compartment, thus I first find the largest compartment and only compute the stuff for that;\n        # the problem with closeness_w is that the names are lost!\n        # find which is the largest compartment:\n        which.is.where <- apply(CO[[1]], 1, function(x) sort(unique(x))[1] )\t\t\t\n        group <- names(sort(table(which.is.where), decreasing=TRUE))[1]\n        keep <- which(CO[[1]] == group, arr.ind=TRUE)\n        subweb <- web[unique(keep[,1]), unique(keep[,2]), drop=FALSE]\n        # now compute closeness_w for that:\n        el2 <- web2edges(subweb, return=TRUE)\n        #if (any(dim(el2)) < 2) return(rep(NA, NROW(web))) # closeness cannot be computed with only one link!\n        proj2 <- projecting_tm(el2, method=method)\n        cc <- closeness_w(proj2, directed=TRUE, gconly=TRUE)[,2]\n        # now pad these results with NAs:\n        cc.full <- rep(NA, NROW(web))\n        if (!is.null(rownames(web))){\n          names(cc.full) <- rownames(web)\n          cc.full[match(rownames(subweb), names(cc.full)) ] <- cc\n          out <- cc.full\n        } else {\n          cc.full[1:length(cc)] <- cc\n          out <- cc.full\n        }\n      }\n      \n      out\n    }\n    \n    CoV <- function(web){\n      \t# variability of interactions, \"species specificity index\", following Poisot et al. (2012) using a normalisation to values between 0 and 1 (originally by Julliard et al. (2006)).\n\t\tnumerator <- sqrt(colSums((web - matrix(colMeans(web), nrow=NROW(web), ncol=NCOL(web), byrow=TRUE))^2))\n\t\tR <- NROW(web)\n\t\tdenominator <- colSums(web) * sqrt((R-1)/R) \n\t\tnumerator/denominator\n   \t}\n\n    PropSimilarity <- function(species_use, abuns){\n    \t# by Jochen Fründ\n        p_i <- species_use / sum(species_use)\n        q_i <- abuns / sum(abuns)\n        sum(pmin(p_i, q_i))  \n    }\n\n   PSI <- function(web, beta=c(1,0)){\n      # calculates the average contribution per visit for each pollinator species\n      # (which in itself depends on the specialisation and abundance of the bees,\n      # as well as the abundance of the plant species)\n      #\n      # web   a pollination web, with plants in rows\n      # beta  a parameter accounting for the fact that two repeated landings are\n      #       needed to transfer pollen: one for the source, one for the sink; a\n      #       value of 2 would assume no memory of plant species in the pollinator;\n      #  \ta value of 1 implies infinitely storing pollen from source to sink plant\n      #\n      # developed by Dormann, Blüthgen & Gruber, 3 May 2007\n      #\n      # example:\n      # m <- matrix(c(4,4,0,4,1,7), nrow=3, byrow=TRUE)\n      # PSI(m, beta=1)\n      \n      Wi. <- matrix(rep(colSums(web), NROW(web)), nrow=NROW(web), byrow=TRUE)\n      W.j <- matrix(rep(rowSums(web), NCOL(web)), ncol=NCOL(web), byrow=FALSE)\n      \n      PSImat <- (web/W.j)^beta * web/Wi.\n      (PSI <- colSums(PSImat))\n    }\n   \n   shannon <- function(x, base=exp(1)) {# shannon's diversity index\n   \t\tPvec <- x/sum(x)\n   \t\t-sum(Pvec*log(Pvec, base=base), na.rm=TRUE)\n   \t} \n    \n    ############### overall computations ####################\n\n    if (\"normalised degree\" %in% index){\n      nds <- ND(web)\n    }\n    \n    if (\"nestedrank\" %in% index){\n    \tnested.ranks <- nestedrank(web, method=nested.method, normalise=nested.normalised, weighted=nested.weighted)\n    }\n    \n    if (any(c(\"species strength\", \"dependence\", \"interaction push pull\") %in% index)){\n      depL <- web/matrix(rowSums(web), nrow=NROW(web), ncol=NCOL(web), byrow=FALSE)\n      depH <- web/matrix(colSums(web), nrow=NROW(web), ncol=NCOL(web), byrow=TRUE)\n      Dij <- depH-depL  # positive values indicate a stronger effect of i (=plants) on j (bees) than vice versa\n    }\n    \n    if (\"NSI\" %in% index){\n      NS <- nodespec(web)\n    }\n    \n    if (\"betweenness\" %in% index){\n      bcs <- BC(web)\n    }\n    \n    if (\"closeness\" %in% index){\n      ccs <- CC(web)\n    }\n    \n    if (any(c(\"partner diversity\", \"effective partners\", \"proportional generality\") %in% index)){\n      preytot.mat <- matrix(rep(colSums(web), NROW(web)), NROW(web), byrow=TRUE)\n      preyprop.mat <- web/preytot.mat  # = b_ik/b_.k in the first formula\n      #H_Nk is the diversity index of inflow (diversity of flower visits for each pollinator)\n      predtot.mat <- matrix(rep(rowSums(web), NCOL(web)), NROW(web), byrow=FALSE)\n      predprop.mat <- web/predtot.mat  # = b_kj/b_.k in the second formula\n      H_Nk <- apply(preyprop.mat, 2, shannon, base=logbase)\n      #H_Pk is the diversity index of pollinators for each plant species\n      H_Pk <- apply(predprop.mat, 1, shannon, base=logbase)\n      # next, we need the reciprocals of this\n      # note that the ifelse is only needed if the web contains prey that is\n      # not eaten or predators that don't eat ...\n      n_Nk <- ifelse(colSums(web) != 0, logbase^H_Nk, 0)\n      n_Pk <- ifelse(rowSums(web) != 0, logbase^H_Pk, 0)\n    }\n    \n    \n    \n    ################################ higher level computations #########################\n    if (for.higher){ \n      \n    # species degrees:\n    if (\"degree\" %in% index){\n      sdH <- colSums(web>0)\n      higher.out$\"degree\" <- unlist(sdH)\n    }\n    \n    # normalised degrees:\n    if (\"normalised degree\" %in% index){\n      higher.out$\"normalised degree\" <- nds[[2]]\n    }\n    \n    # nested ranks:\n    if (\"nestedrank\" %in% index){\n    \thigher.out$\"nestedrank\" <- nested.ranks[[\"higher level\"]]\n    }\n    \n    # dependence values, following the lead by Bascompte et al. 2006 (Science) and modifications suggested by Blüthgen et al. 2007 (Current Biology)\n    if (any(c(\"species strength\", \"dependence\", \"interaction\") %in% index)){\n      #if (\"dependence\" %in% index){ # moved to linklevel!\n      #  higher.out$\"dependence\" <- depH\n      #}\n      # species strength:\n      if (\"species strength\" %in% index){ # strength = sum of dependences for a species (referenced in Bascompte et al. 2006)               \n        SH <- colSums(depL) # accordingly ...\n        higher.out$\"species strength\" <- SH\n      } \n      # Interaction asymmetry (Vazquez et al. 2007, Oikos); rather similar to dependence above, really\n      if (\"interaction push pull\" %in% index) {\n        Aihigh <- colSums(-Dij)/colSums(web>0)\n        higher.out$\"interaction push pull\" <- Aihigh\n      } \n    } # end strength/dependence/interaction\n\n#! JFedit: this is PDI not PSI; before it returned PairedDifferenceIndex when asking for pollination support index...; name changed below as well\n    # Poisot's paired differences index\n      # comments should be adjusted here and below, though\n    if (any(c(\"PDI\", \"paired differences index\") %in% index)){\n      higher.out$\"PDI\" <- PDI(web, normalise=PDI.normalise, log=FALSE)\n    }\n    \n    # resource range\n    if (\"resource range\" %in% index){\n    \thigher.out$\"resource range\" <- PDI(web>0)\t\n    }\n    \n    # species specificity (Juillard) = Coefficient of Variation (Poisot)\n    if (\"species specificity\" %in% index){\n    \thigher.out$\"species specificity index\" <- CoV(web)\n    }\n\n    \n    # Pollination webs only: Pollination service index\n    if (any(c(\"PSI\", \"pollination service index\") %in% index)){    \n      if (for.lower & for.higher & length(PSI.beta) < 2) stop(\"You need to provide 2 values (in a vector) for PSI.beta.\")\n      higher.out$\"PSI\" <- PSI(web, beta=PSI.beta[1])\n    }\n    \n    # node specialisation:\n    if (\"NSI\" %in% index){\n      higher.out$\"node specialisation index NSI\" <- NS$higher\n    }\n    \n    # betweenness (incl. weighted):\n    if (\"betweenness\" %in% index){\n      higher.out$\"betweenness\" <- bcs[[2]]\n      higher.out$\"weighted betweenness\" <- BCC_weighted(web, level=\"higher\")\n    }\n    \n    #closeness\n    if (\"closeness\" %in% index){\n      higher.out$\"closeness\" <- ccs[[2]]\n      higher.out$\"weighted closeness\" <- BCC_weighted(web, level=\"higher\", index=\"closeness\")\n    }\n    \n    # Fisher alpha:\n    if (\"Fisher alpha\" %in% index){\n      ff.high <- try(suppressWarnings(fisher.alpha(web, MARGIN=2)), silent=TRUE)\n      higher.out$\"Fisher alpha\" <- if (!inherits(ff.high, \"try-error\")) ff.high else rep(NA, times=NCOL(web))\n    }\n    \n    # diversity:\n    if (\"partner diversity\" %in% index){\n      higher.out$\"partner diversity\" <- H_Nk\n    }\n    \n    # effective number of partners:\n    if (\"effective partners\" %in% index){\n      higher.out$\"effective partners\" <- n_Nk\n    }\n\n    # proportional similarity (Jochen Fründ 2013)\n    if (\"proportional similarity\" %in% index){\n   \t  # Feinsinger P, Spears EE, Poole RW: A simple measure of niche breadth. Ecology 1981, 61:27-32.\n      mylow.abun <- if (is.null(low.abun)) mylow.abun <- rowSums(web) else mylow.abun <- low.abun\n      psH <- apply(web, 2, PropSimilarity, abuns=mylow.abun) # uses the same abuns as dprime!\n      higher.out$\"proportional similarity\" <- psH\n    }\n    \n    # proportional generality\n    # by Jochen Fründ March 2013\n    if (\"proportional generality\" %in% index){\n      mylow.abun <- if (is.null(low.abun)) mylow.abun <- rowSums(web) else mylow.abun <- low.abun\n      pgenH <- n_Nk / logbase^(shannon(mylow.abun, base=logbase))      # uses the same abuns as dprime!\n      higher.out$\"proportional generality\" <- pgenH\n    }\n    \n    # species-level standardised diversity index d\n    if (\"d\" %in% index){\n      dsH <- dfun(t(web), abuns=low.abun)[[1]]\n      higher.out$d <- dsH\n    }\n\n    \n    } # end condition \"for.higher\"\n    \n    \n    \n    ################################ lower level computations #########################\n    if (for.lower){\n    \n    # species degrees:\n    if (\"degree\" %in% index){\n      sdL <- rowSums(web>0)\n      lower.out$\"degree\" <- sdL\n    }\n\n    # normalised degrees:\n    if (\"normalised degree\" %in% index){\n      lower.out$\"normalised degree\" <- nds[[1]]\n    }\n\n    # nested ranks:\n    if (\"nestedrank\" %in% index){\n    \tlower.out$\"nestedrank\" <- nested.ranks[[\"lower level\"]]\n    }\n    \n    # dependence values, following the lead by Bascompte et al. 2006 (Science) and modifications suggested by Blüthgen et al. 2007 (Current Biology)\n    if (any(c(\"species strength\", \"dependence\", \"interaction\") %in% index)){\n      if (\"dependence\" %in% index){\n        lower.out$\"dependence\" <- depL\n      }\n      # species strength:\n      if (\"species strength\" %in% index){\n        # strength = sum of dependences for a species (referenced in Bascompte et al. 2006)\n        SL <- rowSums(depH) # a plant's strength is the sum of the dependencies of all its pollinators\n        lower.out$\"species strength\" <- SL\n      } \n      # Interaction asymmetry (Vazquez et al. 2007, Oikos); rather similar to dependence above, really\n      if (\"interaction push pull\" %in% index) {\n        Ailow <- rowSums(Dij)/rowSums(web>0)\n        lower.out$\"interaction push/pull\" <- Ailow\n      }\n    } # end strength/dependence/interaction\n    \n    # Poisot's paired differences index\n    if (any(c(\"PDI\", \"paired differences index\") %in% index)){\n      lower.out$\"PDI\" <- PDI(t(web), normalise=PDI.normalise, log=FALSE)\n    }\n\n    # resource range\n    if (\"resource range\" %in% index){\n    \tlower.out$\"resource range\" <- PDI(t(web)>0)\t\n    }\n\n    # Pollinator support index:\n    if (any(c(\"PSI\", \"pollinator support index\") %in% index)){    \n      if (for.lower & for.higher & length(PSI.beta) < 2) stop(\"You need to provide 2 values (in a vector) for PSI.beta.\")\n      # need to accomodate a length-1-vector when only single level output is requested (not needed for PSI.higher):\n      if (length(PSI.beta) == 1) PSI.beta.lower <- PSI.beta[1] else PSI.beta.lower <- PSI.beta[2]\n      lower.out$\"PSI\"   <- PSI(t(web), beta=PSI.beta.lower)\n    }\n    \n    # node specialisation:\n    if (\"NSI\" %in% index){\n      lower.out$\"node specialisation index NSI\" <- NS$lower\n    }\n    \n    # species specificity (Juillard) = Coefficient of Variation (Poisot)\n    if (\"species specificity\" %in% index){\n    \tlower.out$\"species specificity index\" <- CoV(t(web))\n    }\n    \n    # betweenness (incl. weighted)\n    if (\"betweenness\" %in% index){  \n      lower.out$\"betweenness\" <- bcs[[1]]\n      lower.out$\"weighted betweenness\" <- BCC_weighted(web, level=\"lower\") \n    }\n    \n    # closeness:\n    if (\"closeness\" %in% index){\n      lower.out$\"closeness\" <- ccs[[1]]\n      lower.out$\"weighted closeness\" <- BCC_weighted(web, level=\"lower\", index=\"closeness\") \n    }\n    \n    # Fisher alpha:\n    if (\"Fisher alpha\" %in% index){\n      ff.low <- try(suppressWarnings(fisher.alpha(web, MARGIN=1)), silent=TRUE)\n      lower.out$\"Fisher alpha\" <- if (!inherits(ff.low, \"try-error\")) ff.low else rep(NA, times=NROW(web))\n    }\n    \n    # diversity:\n    if (\"partner diversity\" %in% index){\n      lower.out$\"partner diversity\" <- H_Pk\n    }\n    \n    # effective number of partners:\n    if (\"effective partners\" %in% index){\n      lower.out$\"effective partners\" <- n_Pk\n    }\n\n    #JFedit:\n    # proportional similarity\n    if (\"proportional similarity\" %in% index){\n      myhigh.abun <- if (is.null(high.abun)) myhigh.abun <- colSums(web) else myhigh.abun <- high.abun\n      psL <- apply(web, 1, PropSimilarity,abuns=myhigh.abun) # uses the same abuns as dprime!\n      lower.out$\"proportional similarity\" <- psL\n    }\n    # Feinsinger P, Spears EE, Poole RW: A simple measure of niche breadth. Ecology 1981, 61:27-32.\n    \n    # proportional generality\n    # by Jochen Fründ March 2013\n    if (\"proportional generality\" %in% index){\n      myhigh.abun <- if (is.null(high.abun)) myhigh.abun <- colSums(web) else myhigh.abun <- high.abun\n      pgenL <- n_Pk / logbase^(shannon(myhigh.abun, base=logbase))  # uses the same abuns as dprime!\n      lower.out$\"proportional generality\" <- pgenL\n    }\n\n    # species-level standardised diversity index d\n    if (\"d\" %in% index){\n      dsL <- dfun(web, abuns=high.abun)[[1]]\n      lower.out$d <- dsL\n    }\n    \n    \n    } # end condition \"for.lower\"\n    \n    \n    #---------------------------------------------------------------------------\n    if (!(\"dependence\" %in% index)) {\n        higher.out <- as.data.frame(higher.out)\n        lower.out <- as.data.frame(lower.out)\n    }\n    \n    if (level == \"lower\") out <- lower.out\n    if (level == \"higher\") out <- higher.out\n    if (level == \"both\") out <- list(\"higher level\"=higher.out, \"lower level\"=lower.out)  \n    \n    out\n}\n\n\n#specieslevel(bezerra2009, index=\"ALLBUTD\", level=\"both\", PSI.beta=c(1,1))\n#specieslevel(bezerra2009, index=c(\"degree\", \"PSI\"), level=\"lower\")\n#specieslevel(Safariland)\n#specieslevel(Safariland, index=\"dependence\", level=\"lower\")\n#specieslevel(Safariland, index=c(\"dependence\", \"d\", \"effective partners\"), level=\"lower\")\n\n\n#JFedit:\n # below here some tests of the new functions, can be deleted most likely\n#specieslevel(bezerra2009, level=\"higher\", index=c(\"proportional similarity\", \"proportional generality\"))\n\n#plot(specieslevel(web=Safariland, level=\"higher\", PSI.beta=c(1,1), index=c(\"proportional similarity\", \"proportional generality\")))\n#cor(specieslevel(Safariland, level=\"higher\", PSI.beta=c(1,1),index=c(\"proportional similarity\", \"proportional generality\", \"d\")))\n#cor(specieslevel(Safariland, level=\"higher\", PSI.beta=c(1,1),index=c(\"proportional similarity\", \"proportional generality\", \"d\"))[colSums(Safariland)>10,])\n\n#plot(specieslevel(Safariland, level=\"higher\", PSI.beta=c(1,1),index=c(\"proportional similarity\"))[,1])\n#plot(specieslevel(Safariland, level=\"higher\", PSI.beta=c(1,1),index=c(\"proportional similarity\"))[,1], dfun(t(Safariland))$d)\n#specieslevel(Safariland, level=\"both\", PSI.beta=c(1,1),index=c(\"proportional similarity\"))\n#specieslevel(Safariland, level=\"both\", PSI.beta=c(1,1),index=c(\"proportional generality\"))\n",
    "created" : 1384099605353.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "223471760",
    "id" : "1F4C14C4",
    "lastKnownWriteTime" : 1384100548,
    "path" : "C:/DATEN_arbeit/Dropbox/_SharedFolders/Carsten/bipartite/R/specieslevel.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}