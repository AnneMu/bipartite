{
    "contents" : "## bipartite test file ##\n\n## CHECK R-CONSOLE FOR RED TEXT INDICATING ERRORS!! ##\n\n\n\n## run this file after every change in bipartite before submitting it to CRAN!!\n## compile and install bipartite before running this! Do not run on R-functions directly (see bottom!)\nrequire(bipartite)\n\n# lazy load data does not require data to be loaded via \"data(.)\"!\n#  as.one.mode\nimage(as.one.mode(Safariland))\nvisweb(as.one.mode(Safariland, project=\"lower\", fill=NA), NA.col=\"green\") #NA.col should have no effect and cause no problem!\n# check fill=NA and visweb's NA.col:\nvisweb(as.one.mode(vazquenc, fill=NA), NA.col=\"green\") #slow!\n\n# C.score\nC.score(Safariland, FUN=sd, normalise=T) # check that \"any\" functions works!\n\n# compart\ncompart(Safariland) # a comparted network\ncompart(bezerra2009) # an uncomparted network\n\n# computeModules\n## a lot to test here! let's start with the problem of calling computeModules twice in a row:\ncomp1 <- computeModules(vazquenc)\ncomp2 <- computeModules(vazquenc)\n# to be continued ...\n\n# czvalues\nczvalues(comp1)\n\n# degreedistr\ndegreedistr(web=memmott1999)\ndegreedistr(web=memmott1999, pure.call=F)\ndegreedistr(web=memmott1999, pure.call=F, level=\"lower\")\ndegreedistr(web=memmott1999, pure.call=T, level=\"lower\")\ndegreedistr(web=memmott1999, pure.call=T, level=\"higher\", las=1)\n\n# dfun\nset.seed(2)\ndfun(vazquenc, abuns=runif(24, 1,9)) # checks whether external abundances are accepted\ndfun(t(vazquenc), abuns=runif(7, 1,9)) # checks whether external abundances are accepted\n\n# discrepancy\ndiscrepancy(vazquenc)\n#nested(vazquenc, method=\"discrepancy2\")\n## Not nice, this; it's a namespace issue; somehow permute::allPerms is not available to nesteddisc, forcing me to load all of vegan here! Don't know what's going wrong.\n## OUTCOMMENTED because otherwise vegan would be loaded (through nested)! That would obviously affect the check of all following functions!\n\n# empty\nvazquenc[,3] <- 0\nempty(vazquenc, count=TRUE)\nrm(vazquenc)\n\n# endpoint\nendpoint(vazquenc)\n\n# extinction: see second.extinct\n\n# fc\nfc(t(Safariland), dist=\"canberra\", method=\"complete\")\nfc(t(Safariland), dist=\"euc\", method=\"single\")\n\n# frame2webs ...\n\n# genweb\ngenweb(10, 20, 4)\n\n# grouplevel\ngrouplevel(vazquenc)\ngrouplevel(vazquenc, level=\"higher\")\ngrouplevel(vazquenc, level=\"lower\", weighted=FALSE)\ngrouplevel(vazquenc, level=\"lower\", weighted=TRUE, index=c(\"niche overlap\"))\ngrouplevel(vazquenc, level=\"higher\", weighted=TRUE, index=c(\"niche overlap\", \"fd\", \"weighted cluster coefficient\"))\n\n# H2fun\nset.seed(2)\nhist(sapply(nullmodel(vazquenc, 50),  function(x) H2fun(x)[[1]])) # should be close to 0\nH2fun(matrix(runif(100, 2, 100), 10, 10), H2_integer=FALSE)\n\n# linklevel\nstr(linklevel(memmott1999, index=c(\"dependence\", \"endpoint\")))\n\n# listModuleInformation\nif (!exists(\"comp1\")) comp1 <- computeModules(vazquenc)\nlistModuleInformation(comp1)\n\n# ND, BC, CC\nND(vazquenc)\nBC(vazquenc)\nBC(vazquenc, rescale=FALSE, weighted=FALSE)\nCC(vazquenc)\n\n# nested\n#nested(vazquenc, method=\"ALL\")\n## OUTCOMMENTED because otherwise vegan would be loaded (through nested)! That would obviously affect the check of all following functions!\n\n# nestedness\nnestedness(Safariland, n.nulls=20)[c(4, 9:20)]\nnestedness(Safariland, null.models=FALSE)$temperature\n\n# nestedrank\nnestedrank(Safariland, normalise=F)\nnestedrank(Safariland, weighted=F, normalise=F)\nnestedrank(Safariland, method=\"binmatnest\")\nnestedrank(Safariland, method=\"wine\")\nnestedrank(Safariland, method=\"wine\", weighted=FALSE)\nnestedrank(Safariland, method=\"sort\")\nnestedrank(Safariland, method=\"otto\")\n\n\n# networklevel\nnetworklevel(vazquenc)\nnetworklevel(vazquenc, index=\"networklevel\")\nnetworklevel(vazquenc, index=\"networklevel\", weighted=FALSE)\nnetworklevel(vazquenc, index=\"quantitative\")\nnetworklevel(vazquenc, index=\"H2\")\nnetworklevel(vazquenc, index=c(\"H2\", \"cluster coefficient\"))\nnetworklevel(vazquenc, legacy=TRUE)\n# check that double calls to an index do work:\nnetworklevel(matrix(rpois(16,4),nrow=4),c(\"H2\",\"H2\"))\n\n# nodespec\nnodespec(Safariland)\nnodespec(Safariland, inf.replace=Inf)\n\n# npartite ...\n\n# null.distr\nnull.distr(2, vazquenc)\nnull.distr(2, vazquenc>0, distr=\"negative binomial\") # tests whether it works with binary data\n\n# null.t.test\nnull.t.test(vazquenc, N=30, index=\"connectance\") # does it work with one index? \nnull.t.test(vazquenc, N=30, index=c(\"connectance\", \"linkage density\")) # does it work with one index?\n\n# nullmodel\nlapply(1:5, function(x) nullmodel(vazquenc, N=2, method=x))\nlapply(c(\"r2d\", \"swap.web\", \"vaznull\", \"shuffle.web\", \"mgen\"), function(x) nullmodel(vazquenc, N=2, method=x))\n\n# PAC\nPAC(vazquenc)\nPAC(vazquenc>0)\n\n# PDI\nPDI(vazquenc, normalise=FALSE, log=TRUE)\nPDI(vazquenc>0)\n\n# plotModuleWeb\nif (!exists(\"comp1\")) comp1 <- computeModules(vazquenc)\nplotModuleWeb(comp1)\nplotModuleWeb(comp1, plotModules = TRUE, rank = TRUE, weighted = TRUE, displayAlabels = TRUE, displayBlabels = TRUE, labsize = 0.6, xlabel = \"\", ylabel = \"\", square.border = \"lightgreen\", fromDepth = 0, upToDepth = -1)\n\n# plotPAC\nplotPAC(PAC(vazquenc))\nplotPAC(PAC(vazquenc), scaling = 2, plot.scale = 1.5, fill.col = rgb(0.2, 0.3, 0.4, 0.5), arrow.col = rgb(0.4, 0.3, 0.2, 0.5), outby = 0.5, text = TRUE, circles = TRUE, radius = 1.5)\n\n# plotweb\nplotweb(vazquenc)\n# test of Jochen's workaround:\nplotweb(vazquenc,abuns.type='independent')\nplotweb(Safariland, abuns.type='independent')\nplotweb(Safariland, abuns.type='independent',arrow=\"down.center\")\nplotweb(Safariland, abuns.type='additional',arrow=\"down.center\")\n# an example set with abundances\nmyabuns.low <- rowSums(Safariland)\nmyabuns.low[rownames(vazquenc)] <- myabuns.low[rownames(vazquenc)] + rowSums(vazquenc)          # \"total abundances\" (might be independent)\nmyabuns.low.unused <- myabuns.low - rowSums(Safariland)[names(myabuns.low)]                     # \"unused abundances\"\nplotweb(Safariland, abuns.type='independent',arrow=\"down.center\",low.abun=myabuns.low)          # that's correct\nplotweb(Safariland, abuns.type='additional',arrow=\"down.center\",low.abun=myabuns.low)           # that's wrong\nplotweb(Safariland, abuns.type='additional',arrow=\"down.center\",low.abun=myabuns.low.unused)    # that's how it should look like for the additional case\nplotweb(Safariland, abuns.type='independent',arrow=\"down.center\",low.abun=myabuns.low*0.2)      # still works\nplotweb(Safariland, abuns.type='additional',arrow=\"down.center\",low.abun=myabuns.low*0.2)       # always shows marginals as abundances\nplotweb(Safariland, abuns.type='independent',arrow=\"no\",low.abun=myabuns.low*0.2)               # currently gives a warning, but the ratio between upper width and lower width could actually tell you something about preferences!\n\n\n\n\n# plotweb2 ...\n\n# printoutModuleInformation\nif (!exists(\"comp1\")) comp1 <- computeModules(vazquenc)\nprintoutModuleInformation(comp1)\n\n# robustness\n\n# second.extinct\nbs <- second.extinct(Safariland, method=\"random\", participant=\"both\", details=T) \nslope.bipartite(bs) # should return an error with an explanation\nbs <- second.extinct(Safariland, method=\"random\", participant=\"both\", details=F) \nslope.bipartite(bs) # should work\n\n\n# slope.bipartite\n\n# sortweb\n\n# specieslevel\nspecieslevel(bezerra2009)\nspecieslevel(bezerra2009, index=\"betweenness\") # lower level is all NaN (I guess because bezerra is nearly complete as one-mode?\nspecieslevel(Safariland, index=\"betweenness\")\nspecieslevel(Safariland, index=\"closeness\")\nspecieslevel(bezerra2009, level=\"higher\", index=c(\"proportional similarity\", \"proportional generality\"))\nspecieslevel(Safariland, index=\"nestedrank\", nested.weighted=T)\nspecieslevel(Safariland, index=\"nestedrank\", nested.weighted=F)\nspecieslevel(Safariland, index=\"nestedrank\", nested.weighted=T, nested.normalise=F)\nspecieslevel(Safariland, index=\"nestedrank\", nested.weighted=F, nested.normalise=F)\nspecieslevel(Safariland, index=\"nestedrank\", nested.weighted=F, nested.normalise=T, nested.method=\"wine\")\nspecieslevel(Safariland, index=\"nestedrank\", nested.weighted=F, nested.normalise=F, nested.method=\"sort\")\n\n# from Jochen's reported errors in specieslevel:\nspecieslevel(matrix(rpois(16,3),nrow=4),index=\"ALLBUTD\")\nspecieslevel(matrix(c(0,0,5,0,0,5,0,0,5,0,0,5),nrow=3,byrow=T),index=\"closeness\", level=\"higher\")\nspecieslevel(matrix(c(0,0,5,0,0,5,0,0,5,0,0,5),nrow=3,byrow=T),index=\"closeness\", level=\"lower\")\nspecieslevel(matrix(c(0,0,5,0,0,5,0,0,5,0,0,5),nrow=3,byrow=T),index=\"betweenness\", level=\"lower\")\nspecieslevel(matrix(c(0,0,5,0,0,5,0,0,5,0,0,5),nrow=3,byrow=T),index=\"betweenness\", level=\"higher\")\n# strength\n\n# swap.web\n\n# togetherness\n\n# V.ratio\n\n# visweb\n\n# web2edges\n\n# webs2array\n\n# wine\n\n\n\n## ----------some not so bright ideas ---------##\n###source function to make sure we use the most recent ones:\n# NOT SO BRIGHT! because the namespace will import specified functions. When we now load the functions via source, these imported functions are NOT available, unless we explicitly load the package, too:\n#setwd(\"/Users/cdormann/Data/aktuell/BESS/R_FoodWeb/\")\n#rfiles <- list.files(\"bipartite/R\")\n## source files, excluding zzz.r\n#for (i in seq_along(rfiles)[-length(rfiles)]) source(paste0(\"bipartite/R/\", rfiles[i]))\n# C.score(Safariland) # error: could not find \"designdist\"\n",
    "created" : 1384102346380.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "540095445",
    "id" : "A82EA89C",
    "lastKnownWriteTime" : 1383495747,
    "path" : "C:/DATEN_arbeit/Dropbox/_SharedFolders/Carsten/bipartite_testfile.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}